---
// Draw a 3D trefoil knot using ASCII characters
---

<div
  id="ascii-canvas"
  class="absolute inset-0 z-30 ascii-background bg-white opacity-70"
>
</div>

<script>
  class TrefoilKnotRenderer {
    container: HTMLElement;
    canvas: HTMLPreElement;
    asciiChars: string;
    time: number;
    animationSpeed: number;
    knotRadius: number;
    scale: number;
    perspective: number;
    width: number;
    height: number;
    knotPoints: Array<{ x: number; y: number; z: number }>;
    knotSamples: number;

    constructor(container: HTMLElement) {
      this.container = container;
      this.canvas = document.createElement("pre");
      this.canvas.style.margin = "0";
      this.canvas.style.padding = "0";
      this.canvas.style.lineHeight = "1";
      this.canvas.style.fontFamily = "monospace";
      this.canvas.style.fontSize = "10px";
      this.canvas.style.overflow = "hidden";
      this.canvas.style.whiteSpace = "pre";
      this.canvas.style.color = "#d0d0d0";
      this.container.appendChild(this.canvas);
      this.width = 0;
      this.height = 0;

      // ASCII characters from darkest to brightest
      this.asciiChars = " .:-=+*#%@";

      // Animation parameters
      this.time = 0;
      this.animationSpeed = 0.1;

      // Rendering parameters
      this.knotRadius = 1.5; // Radius of the tube around the knot
      this.scale = 15; // Scale factor for the knot
      this.perspective = 400; // Perspective distance

      // Pre-compute knot points
      this.knotSamples = 100;
      this.knotPoints = [];
      for (let i = 0; i < this.knotSamples; i++) {
        const t = (i / this.knotSamples) * Math.PI * 2;
        this.knotPoints.push(this.trefoilKnot(t));
      }

      this.setupResize();
      this.animate();
    }

    setupResize() {
      const resize = () => {
        const rect = this.container.getBoundingClientRect();
        this.width = Math.floor(rect.width / 6); // Approximate char width
        this.height = Math.floor(rect.height / 10); // Approximate char height
        this.render();
      };

      window.addEventListener("resize", resize);
      resize();
    }

    // Parametric equations for a trefoil knot
    trefoilKnot(t: number) {
      const x = Math.sin(t) + 2 * Math.sin(2 * t);
      const y = Math.cos(t) - 2 * Math.cos(2 * t);
      const z = -Math.sin(3 * t);
      return { x, y, z };
    }

    // Rotate point around X axis
    rotateX(p: { x: number; y: number; z: number }, angle: number) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        x: p.x,
        y: p.y * cos - p.z * sin,
        z: p.y * sin + p.z * cos,
      };
    }

    // Rotate point around Y axis
    rotateY(p: { x: number; y: number; z: number }, angle: number) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        x: p.x * cos + p.z * sin,
        y: p.y,
        z: -p.x * sin + p.z * cos,
      };
    }

    // Rotate point around Z axis
    rotateZ(p: { x: number; y: number; z: number }, angle: number) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        x: p.x * cos - p.y * sin,
        y: p.x * sin + p.y * cos,
        z: p.z,
      };
    }

    // Project 3D point to 2D with perspective
    project(p: { x: number; y: number; z: number }) {
      const factor = this.perspective / (this.perspective + p.z);
      return {
        x: p.x * factor,
        y: p.y * factor,
        z: p.z,
      };
    }

    // Calculate distance from a point to the knot surface (optimized)
    distanceToKnot(px: number, py: number, pz: number) {
      let minDist = Infinity;

      // Pre-compute rotation matrices
      const cosX = Math.cos(this.time * 0.5);
      const sinX = Math.sin(this.time * 0.5);
      const cosY = Math.cos(this.time * 0.7);
      const sinY = Math.sin(this.time * 0.7);
      const cosZ = Math.cos(this.time * 0.3);
      const sinZ = Math.sin(this.time * 0.3);

      for (let i = 0; i < this.knotSamples; i++) {
        const knot = this.knotPoints[i];

        // Combined rotation (X, then Y, then Z) - inlined for speed
        // Rotate X
        let x = knot.x;
        let y = knot.y * cosX - knot.z * sinX;
        let z = knot.y * sinX + knot.z * cosX;

        // Rotate Y
        const tempX = x * cosY + z * sinY;
        z = -x * sinY + z * cosY;
        x = tempX;

        // Rotate Z
        const finalX = x * cosZ - y * sinZ;
        const finalY = x * sinZ + y * cosZ;

        // Scale
        const scaledX = finalX * this.scale;
        const scaledY = finalY * this.scale;
        const scaledZ = z * this.scale;

        // Calculate distance
        const dx = px - scaledX;
        const dy = py - scaledY;
        const dz = pz - scaledZ;
        const dist = dx * dx + dy * dy + dz * dz; // Use squared distance to avoid sqrt

        if (dist < minDist) {
          minDist = dist;
        }
      }

      return Math.sqrt(minDist);
    }

    // Render the knot
    render() {
      if (!this.width || !this.height) return;

      const buffer: string[] = [];
      const aspectRatio = this.width / this.height;
      const knotRadiusScaled = this.knotRadius * this.scale;
      const knotRadiusScaledSq = knotRadiusScaled * knotRadiusScaled;

      for (let y = 0; y < this.height; y++) {
        let row = "";
        for (let x = 0; x < this.width; x++) {
          // Map screen coordinates to world coordinates
          const worldX = (x / this.width - 0.5) * 60 * aspectRatio;
          const worldY = (y / this.height - 0.5) * 60;

          // Simplified ray marching - fewer steps
          let brightness = 0;
          const raySteps = 15; // Reduced from 30

          for (let step = 0; step < raySteps; step++) {
            const depth = -50 + (step * 100) / raySteps;
            const dist = this.distanceToKnot(worldX, worldY, depth);
            const distSq = dist * dist;

            // If we're close to the surface, calculate brightness
            if (distSq < knotRadiusScaledSq) {
              // Distance from surface (0 = on surface, 1 = at edge of tube)
              const surfaceDist = dist / knotRadiusScaled;

              // Calculate brightness based on distance and depth
              const depthFactor = 1 - (depth + 50) / 100;
              const thisBrightness = (1 - surfaceDist) * depthFactor;

              if (thisBrightness > brightness) {
                brightness = thisBrightness;
              }
            }
          }

          // Map brightness to ASCII character
          const charIndex = Math.floor(
            brightness * (this.asciiChars.length - 1)
          );
          row +=
            this.asciiChars[
              Math.max(0, Math.min(charIndex, this.asciiChars.length - 1))
            ];
        }
        buffer.push(row);
      }

      this.canvas.textContent = buffer.join("\n");
    }

    animate() {
      this.time += this.animationSpeed;
      this.render();
      requestAnimationFrame(() => this.animate());
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      const container = document.getElementById("ascii-canvas");
      if (container) {
        new TrefoilKnotRenderer(container);
      }
    });
  } else {
    const container = document.getElementById("ascii-canvas");
    if (container) {
      new TrefoilKnotRenderer(container);
    }
  }
</script>

<style>
  .ascii-background {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #fff;
  }

  .ascii-background pre {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
  }
</style>
